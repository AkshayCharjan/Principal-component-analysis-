# -*- coding: utf-8 -*-
"""1_iii.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gsljudHdpkays1hIfdXpQEJ25XhcJDgK
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

file= pd.read_csv("./Dataset.csv",header=None,float_precision='round_trip')

plt.scatter(file[0], file[1])
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Data points")
plt.show()

mean_x=file[0].mean()
mean_y=file[1].mean()

file[0]=file[0] - mean_x
file[1]=file[1] - mean_y

def convert(x,y):
    xty=np.dot(x,y)
    return (1+xty)**2

X=file.transpose()

K = np.zeros((1000, 1000))
for i in range (0 ,1000):
    for j in range (0, 1000):
        K[i][j]=convert(X[i],X[j])

#Data Centering 
I=np.identity(1000)
M=I-(1/1000)
MK=np.dot(M,K)
MKM=np.dot(MK,M)

from numpy.lib.twodim_base import triu_indices
e_values, e_vectors = np.linalg.eig(MKM)
z=e_values, e_vectors
e_v=e_vectors.transpose() #[[w1x w1y][w2x w2y]]
pair=[]
for i in range(0,1000):
  t=e_values[i],e_v[i]
  pair.append(t)
pair.sort(reverse=True)

e_vecs=[]
e_vals=[]
for i in pair:
  e_vecs.append(i[1])
  e_vals.append(i[0])

#calculating alpha-k
import math
alpha1 = e_vecs[0]/np.sqrt(e_vals[0])
alpha2 = e_vecs[1]/np.sqrt(e_vals[1])

A=np.dot(MKM,alpha1)
B=np.dot(MKM,alpha2)

plt.scatter(A, B)
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Polynomial Kernel PCA with d=2")
plt.show()

#For d=3
def convert_(x,y):
    xty=np.dot(x,y)
    return (1+xty)**3

K = np.zeros((1000, 1000))
for i in range (0 ,1000):
    for j in range (0, 1000):
        K[i][j]=convert_(X[i],X[j])

#Data Centering 
I=np.identity(1000)
M=I-(1/1000)
MK=np.dot(M,K)
MKM=np.dot(MK,M)  #centered_K

from numpy.lib.twodim_base import triu_indices
e_values, e_vectors = np.linalg.eig(MKM)
z=e_values, e_vectors
e_v=e_vectors.transpose() #[[w1x w1y][w2x w2y]]
pair=[]
for i in range(0,1000):
  t=e_values[i],e_v[i]
  pair.append(t)
pair.sort(reverse=True)

e_vecs=[]
e_vals=[]
for i in pair:
  e_vecs.append(i[1])
  e_vals.append(i[0])

#calculating alpha-k
import math
alpha1 = e_vecs[0]/np.sqrt(e_vals[0])
alpha2 = e_vecs[1]/np.sqrt(e_vals[1])

A=np.dot(MKM,alpha1)
B=np.dot(MKM,alpha2)

plt.scatter(A, B)
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Polynomial Kernel PCA with d=3")
plt.show()

#part B
#for sigma= 0.1

def convertB(x,y,sigma):
    a=(x-y)
    atb=np.dot(a,a)
    c=-atb/(2*sigma**2)
    return math.exp(c)

K = np.zeros((1000, 1000))
sigma=0.1
for i in range (0 ,1000):
      for j in range (i, 1000):
        K[i][j]=convertB(X[i],X[j],0.1)
        K[j][i]=K[i][j]

#Data Centering 
I=np.identity(1000)
M=I-(1/1000)
MK=np.dot(M,K)
MKM=np.dot(MK,M) #centered_K

from numpy.lib.twodim_base import triu_indices
e_values, e_vectors = np.linalg.eig(MKM)
z=e_values, e_vectors
e_v=e_vectors.transpose() #[[w1x w1y][w2x w2y]]
pair=[]
for i in range(0,1000):
  t=e_values[i],e_v[i]
  pair.append(t)
pair.sort(reverse=True)

e_vecs=[]
e_vals=[]
for i in pair:
  e_vecs.append(i[1])
  e_vals.append(i[0])

#calculating alpha-k
import math
alpha1 = e_vecs[0]/np.sqrt(e_vals[0])
alpha2 = e_vecs[1]/np.sqrt(e_vals[1])

A=np.dot(MKM,alpha1)
B=np.dot(MKM,alpha2)

plt.scatter(A, B)
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Radial Basis Function with sigma=0.1")
plt.show()

#for sigma= 0.2

K = np.zeros((1000, 1000))
sigma=0.1
for i in range (0 ,1000):
      for j in range (i, 1000):
        K[i][j]=convertB(X[i],X[j],0.1)
        K[j][i]=K[i][j]

#Data Centering 
I=np.identity(1000)
M=I-(1/1000)
MK=np.dot(M,K)
MKM=np.dot(MK,M) #centered_K

from numpy.lib.twodim_base import triu_indices
e_values, e_vectors = np.linalg.eig(MKM)
z=e_values, e_vectors
e_v=e_vectors.transpose() #[[w1x w1y][w2x w2y]]
pair=[]
for i in range(0,1000):
  t=e_values[i],e_v[i]
  pair.append(t)
pair.sort(reverse=True)

e_vecs=[]
e_vals=[]
for i in pair:
  e_vecs.append(i[1])
  e_vals.append(i[0])

#calculating alpha-k
import math
alpha1 = e_vecs[0]/np.sqrt(e_vals[0])
alpha2 = e_vecs[1]/np.sqrt(e_vals[1])

A=np.dot(MKM,alpha1)
B=np.dot(MKM,alpha2)

plt.scatter(A, B)
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Radial Basis Function with sigma=0.2")
plt.show()

#for sigma= 0.3

K = np.zeros((1000, 1000))
sigma=0.1
for i in range (0 ,1000):
      for j in range (i, 1000):
        K[i][j]=convertB(X[i],X[j],0.3)
        K[j][i]=K[i][j]

#Data Centering 
I=np.identity(1000)
M=I-(1/1000)
MK=np.dot(M,K)
MKM=np.dot(MK,M) #centered_K

from numpy.lib.twodim_base import triu_indices
e_values, e_vectors = np.linalg.eig(MKM)
z=e_values, e_vectors
e_v=e_vectors.transpose() #[[w1x w1y][w2x w2y]]
pair=[]
for i in range(0,1000):
  t=e_values[i],e_v[i]
  pair.append(t)
pair.sort(reverse=True)



e_vecs=[]
e_vals=[]
for i in pair:
  e_vecs.append(i[1])
  e_vals.append(i[0])

#calculating alpha-k
import math
alpha1 = e_vecs[0]/np.sqrt(e_vals[0])
alpha2 = e_vecs[1]/np.sqrt(e_vals[1])

A=np.dot(MKM,alpha1)
B=np.dot(MKM,alpha2)

plt.scatter(A, B)
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Radial Basis Function with sigma=0.3")
plt.show()

#for sigma= 0.4

K = np.zeros((1000, 1000))
sigma=0.1
for i in range (0 ,1000):
      for j in range (i, 1000):
        K[i][j]=convertB(X[i],X[j],0.4)
        K[j][i]=K[i][j]

#Data Centering 
I=np.identity(1000)
M=I-(1/1000)
MK=np.dot(M,K)
MKM=np.dot(MK,M) #centered_K

from numpy.lib.twodim_base import triu_indices
e_values, e_vectors = np.linalg.eig(MKM)
z=e_values, e_vectors
e_v=e_vectors.transpose() #[[w1x w1y][w2x w2y]]
pair=[]
for i in range(0,1000):
  t=e_values[i],e_v[i]
  pair.append(t)
pair.sort(reverse=True)

e_vecs=[]
e_vals=[]
for i in pair:
  e_vecs.append(i[1])
  e_vals.append(i[0])

#calculating alpha-k
import math
alpha1 = e_vecs[0]/np.sqrt(e_vals[0])
alpha2 = e_vecs[1]/np.sqrt(e_vals[1])

A=np.dot(MKM,alpha1)
B=np.dot(MKM,alpha2)

plt.scatter(A, B)
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Radial Basis Function with sigma=0.4")
plt.show()

#for sigma= 0.5

K = np.zeros((1000, 1000))
sigma=0.1
for i in range (0 ,1000):
      for j in range (i, 1000):
        K[i][j]=convertB(X[i],X[j],0.5)
        K[j][i]=K[i][j]

#Data Centering 
I=np.identity(1000)
M=I-(1/1000)
MK=np.dot(M,K)
MKM=np.dot(MK,M) #centered_K

from numpy.lib.twodim_base import triu_indices
e_values, e_vectors = np.linalg.eig(MKM)
z=e_values, e_vectors
e_v=e_vectors.transpose() #[[w1x w1y][w2x w2y]]
pair=[]
for i in range(0,1000):
  t=e_values[i],e_v[i]
  pair.append(t)
pair.sort(reverse=True)



e_vecs=[]
e_vals=[]
for i in pair:
  e_vecs.append(i[1])
  e_vals.append(i[0])

#calculating alpha-k
import math
alpha1 = e_vecs[0]/np.sqrt(e_vals[0])
alpha2 = e_vecs[1]/np.sqrt(e_vals[1])

A=np.dot(MKM,alpha1)
B=np.dot(MKM,alpha2)

plt.scatter(A, B)
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Radial Basis Function with sigma=0.5")
plt.show()

#for sigma= 0.6

K = np.zeros((1000, 1000))
sigma=0.1
for i in range (0 ,1000):
      for j in range (i, 1000):
        K[i][j]=convertB(X[i],X[j],0.6)
        K[j][i]=K[i][j]

#Data Centering 
I=np.identity(1000)
M=I-(1/1000)
MK=np.dot(M,K)
MKM=np.dot(MK,M) #centered_K

from numpy.lib.twodim_base import triu_indices
e_values, e_vectors = np.linalg.eig(MKM)
z=e_values, e_vectors
e_v=e_vectors.transpose() #[[w1x w1y][w2x w2y]]
pair=[]
for i in range(0,1000):
  t=e_values[i],e_v[i]
  pair.append(t)
pair.sort(reverse=True)



e_vecs=[]
e_vals=[]
for i in pair:
  e_vecs.append(i[1])
  e_vals.append(i[0])

#calculating alpha-k
import math
alpha1 = e_vecs[0]/np.sqrt(e_vals[0])
alpha2 = e_vecs[1]/np.sqrt(e_vals[1])

A=np.dot(MKM,alpha1)
B=np.dot(MKM,alpha2)

plt.scatter(A, B)
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Radial Basis Function with sigma=0.6")
plt.show()

#for sigma= 0.7

K = np.zeros((1000, 1000))
sigma=0.1
for i in range (0 ,1000):
      for j in range (i, 1000):
        K[i][j]=convertB(X[i],X[j],0.7)
        K[j][i]=K[i][j]

#Data Centering 
I=np.identity(1000)
M=I-(1/1000)
MK=np.dot(M,K)
MKM=np.dot(MK,M) #centered_K

from numpy.lib.twodim_base import triu_indices
e_values, e_vectors = np.linalg.eig(MKM)
z=e_values, e_vectors
e_v=e_vectors.transpose() #[[w1x w1y][w2x w2y]]
pair=[]
for i in range(0,1000):
  t=e_values[i],e_v[i]
  pair.append(t)
pair.sort(reverse=True)



e_vecs=[]
e_vals=[]
for i in pair:
  e_vecs.append(i[1])
  e_vals.append(i[0])

#calculating alpha-k
import math
alpha1 = e_vecs[0]/np.sqrt(e_vals[0])
alpha2 = e_vecs[1]/np.sqrt(e_vals[1])

A=np.dot(MKM,alpha1)
B=np.dot(MKM,alpha2)

plt.scatter(A, B)
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Radial Basis Function with sigma=0.7")
plt.show()

#for sigma= 0.8

K = np.zeros((1000, 1000))
sigma=0.1
for i in range (0 ,1000):
      for j in range (i, 1000):
        K[i][j]=convertB(X[i],X[j],0.8)
        K[j][i]=K[i][j]

#Data Centering 
I=np.identity(1000)
M=I-(1/1000)
MK=np.dot(M,K)
MKM=np.dot(MK,M) #centered_K

from numpy.lib.twodim_base import triu_indices
e_values, e_vectors = np.linalg.eig(MKM)
z=e_values, e_vectors
e_v=e_vectors.transpose() #[[w1x w1y][w2x w2y]]
pair=[]
for i in range(0,1000):
  t=e_values[i],e_v[i]
  pair.append(t)
pair.sort(reverse=True)



e_vecs=[]
e_vals=[]
for i in pair:
  e_vecs.append(i[1])
  e_vals.append(i[0])

#calculating alpha-k
import math
alpha1 = e_vecs[0]/np.sqrt(e_vals[0])
alpha2 = e_vecs[1]/np.sqrt(e_vals[1])

A=np.dot(MKM,alpha1)
B=np.dot(MKM,alpha2)

plt.scatter(A, B)
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Radial Basis Function with sigma=0.8")
plt.show()

#for sigma= 0.9

K = np.zeros((1000, 1000))
sigma=0.1
for i in range (0 ,1000):
      for j in range (i, 1000):
        K[i][j]=convertB(X[i],X[j],0.9)
        K[j][i]=K[i][j]

#Data Centering 
I=np.identity(1000)
M=I-(1/1000)
MK=np.dot(M,K)
MKM=np.dot(MK,M) #centered_K

from numpy.lib.twodim_base import triu_indices
e_values, e_vectors = np.linalg.eig(MKM)
z=e_values, e_vectors
e_v=e_vectors.transpose() #[[w1x w1y][w2x w2y]]
pair=[]
for i in range(0,1000):
  t=e_values[i],e_v[i]
  pair.append(t)
pair.sort(reverse=True)

e_vecs=[]
e_vals=[]
for i in pair:
  e_vecs.append(i[1])
  e_vals.append(i[0])

#calculating alpha-k
import math
alpha1 = e_vecs[0]/np.sqrt(e_vals[0])
alpha2 = e_vecs[1]/np.sqrt(e_vals[1])

A=np.dot(MKM,alpha1)
B=np.dot(MKM,alpha2)

plt.scatter(A, B)
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Radial Basis Function with sigma=0.9")
plt.show()

#for sigma= 1.0

K = np.zeros((1000, 1000))
sigma=0.1
for i in range (0 ,1000):
      for j in range (i, 1000):
        K[i][j]=convertB(X[i],X[j],1.0)
        K[j][i]=K[i][j]

#Data Centering 
I=np.identity(1000)
M=I-(1/1000)
MK=np.dot(M,K)
MKM=np.dot(MK,M) #centered_K

from numpy.lib.twodim_base import triu_indices
e_values, e_vectors = np.linalg.eig(MKM)
z=e_values, e_vectors
e_v=e_vectors.transpose() #[[w1x w1y][w2x w2y]]
pair=[]
for i in range(0,1000):
  t=e_values[i],e_v[i]
  pair.append(t)
pair.sort(reverse=True)

e_vecs=[]
e_vals=[]
for i in pair:
  e_vecs.append(i[1])
  e_vals.append(i[0])

#calculating alpha-k
import math
alpha1 = e_vecs[0]/np.sqrt(e_vals[0])
alpha2 = e_vecs[1]/np.sqrt(e_vals[1])

A=np.dot(MKM,alpha1)
B=np.dot(MKM,alpha2)

plt.scatter(A, B)
plt.xlabel("x values")
plt.ylabel("y values")
plt.title("Radial Basis Function with sigma=1")
plt.show()